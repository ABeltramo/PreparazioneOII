<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Complessità Computazionale &middot; Preparazione OII
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p></p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
      <a class="sidebar-nav-item" href="/chapters/1-io_file/">I/O da file</a>
    
      <a class="sidebar-nav-item active" href="/chapters/2-complessita/">Complessità Computazionale</a>
    
    <span class="sidebar-nav-item">Currently v1.0.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2017. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Preparazione OII</a>
            <small>Lezioni ed esercizi per la preparazione delle OII</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 id="preparazione-oiireadmemd"><a href="README.md">Preparazione OII</a></h1>
<p>## Complessità computazionale
I problemi che dovrete risolvere alle olimpiadi impongono due importanti limiti sui programmi che andrete a creare:</p>

<ol>
  <li><strong>Memoria</strong>: non si può superare un certo limite di memoria RAM occupata (ad esempio 256 MB)</li>
  <li><strong>Tempo</strong>: bisogna completare l’esecuzione entro un tempo limite (ad esempio 1 secondo)</li>
</ol>

<p>In questo capitolo ci occuperemo di misurare il tempo di un algoritmo mentre nel prossimo parleremo del problema della memoria.</p>

<h3 id="bubble-sort">Bubble Sort</h3>

<p>Uno dei problemi noti dell’informatica riguarda l’ordinamento <em>efficiente</em> di un insieme di oggetti. Il più semplice algoritmo di ordinamento da implementare e da capire è sicuramente <a href="https://it.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a>:</p>

<p><code class="highlighter-rouge">c++
void BubbleSort(int *array, int elemN){
   int alto;
   for (alto = elemN; alto &gt; 0; alto-- ){ 
         for (int i=0; i&lt;alto; i++){
           if (array[i]&gt;array[i+1]){ 
             int tmp = array[i]; 
             array[i] = array[i+1]; 
             array[i+1] = tmp;
           } 
         }
     }
 }
</code></p>

<p>Come <em>dovreste</em> sapere <code class="highlighter-rouge">BubbleSort</code> non è un algoritmo efficiente per l’ordinamento ma come possiamo misurare la sua complessità?<br />
Innanzitutto definiamo cos’è per noi l’<strong>istruzione</strong>: un istruzione è una qualsiasi operazione eseguibile da un computer in un tempo costante <strong>C</strong>. Ad esempio <code class="highlighter-rouge">x+=1;</code> oppure <code class="highlighter-rouge">if(A == B)</code> sono istruzioni semplici.<br />
Nel calcolo della complessità computazionale siamo interessati a capire quanto <em>tempo</em> impiega un determinato algoritmo dato un input di dimensione <strong>N</strong>.
Proviamo a rifare l’analisi per <code class="highlighter-rouge">BubbleSort</code> partendo dalle istruzioni più interne:</p>

<p><code class="highlighter-rouge">C++
    int tmp = array[i];             // *******************
    array[i] = array[i+1];          //      BLOCCO A
    array[i+1] = tmp;               // *******************
</code></p>

<p>Queste tre istruzioni semplici impiegano ognuna tempo <strong>C</strong> quindi diremo che il blocco A impiega tempo <strong>3C</strong>. Proseguiamo verso l’esterno:</p>

<p><code class="highlighter-rouge">C++
    for (int i=0; i&lt;alto; i++){     // *******************
        if (array[i]&gt;array[i+1]){   //
            // [... A ...]          //      BLOCCO B
        }                           //
    }                               // *******************
</code></p>

<p>Il blocco B esegue un ciclo <code class="highlighter-rouge">for</code> che va da 0 ad <code class="highlighter-rouge">alto</code>. Questo ciclo esegue per <code class="highlighter-rouge">alto</code> volte il blocco <code class="highlighter-rouge">if</code> (che corrisponde ad una istruzione <strong>C</strong>). Supponiamo che nel <em>caso peggiore</em> l’array sia ordinato al contrario e quindi si entra nel blocco if ad ogni iterazione. In questo caso il blocco A (<strong>3C</strong>) + l’istruzione <code class="highlighter-rouge">if</code> (<strong>C</strong>) verrano eseguite per <code class="highlighter-rouge">alto</code> volte.<br />
Possiamo concludere, quindi, dicendo che il blocco B ha una complessità nel caso peggiore di <strong>alto * 4C</strong>.</p>

<p><code class="highlighter-rouge">c++
void BubbleSort(int *array, int elemN){
   int alto;
   for (alto = elemN; alto &gt; 0; alto-- ){ 
         // [... B ...]
     }
 }
</code></p>

<p>Possiamo ora considerare l’algoritmo <code class="highlighter-rouge">BubbleSort</code> nel suo insieme.</p>

<ol>
  <li>La variabile <code class="highlighter-rouge">alto</code> viene inizializzata alla dimensione dell’input (<strong>N</strong>)</li>
  <li>Viene eseguito il blocco B portando quindi la complessità a <strong>N * 4C</strong></li>
  <li><code class="highlighter-rouge">alto</code> assume ora il valore <strong>N-1</strong>.</li>
  <li>Viene eseguito il blocco B portando la complessità a <strong>(N*4C) + [(N-1)*4C]</strong></li>
</ol>

<p>Continuando ad eseguire il ciclo si ottiene la seguente equazione:</p>

<p align="center">
    <img src="img/Compl_BubbleSort.png" />
</p>

<p>Non ci interessano molto i calcoli quanto il risultato: la notazione <em>Teta(N^2)</em> significa che l’algoritmo sia nel caso migliore che nel caso peggiore impiega il quadrato della dimensione dell’input. Mi potreste chiedere: <em>“Dove sono finite le C?”</em> e io vi risponderei: <em>“Grazie per avermelo chiesto!”</em>. In realtà lo scopo del calcolo della complessità computazionale non è definire esattamente quanto tempo impiega un programma a completare la sua esecuzione; i secondi esatti dipendono da moltissime variabili come la velocità del processore, il suo set di istruzioni macchina, la compilazione in bytecode, etc etc. <br />
Le <strong>C</strong> spariscono perchè sono insignificanti rispetto alla dimensione dell’input. Cercate sempre di immaginare un vettore di input con tante caselle quante ce ne possono stare nella RAM. Eseguire N volte un codice, 2N, 10N, 100N non è niente paragonato a <strong>N^2</strong> (se provate a mettere numeri grandi capirete il perchè).<br />
Da qui in avanti useremo la notazione <strong>O(tempo)</strong> (da leggersi O grande di) per indicare il <em>caso peggiore</em> dell’algoritmo.</p>

<h3 id="stupid-sort">Stupid Sort</h3>

<p><a href="https://it.wikipedia.org/wiki/Stupid_sort">Stupid Sort</a> è un algoritmo di ordinamento pessimo (basta leggerne il nome) eppure la prima cosa che salta all’occhio è il codice. Sono solo tre righe, <a href="https://media.giphy.com/media/8McNH1aXZnVyE/giphy.gif">un solo ciclo</a> com’è possibile che sia così pessimo?</p>

<pre><code class="language-language">function stupid_sort(array)
   while not is_sorted(array)
     array = random_permutation(array)
</code></pre>

<p>Dato un array da ordinare si continua a permutarlo a random fino a quando esso non è ordinato. La cosa buffa è che il <a href="https://it.wikipedia.org/wiki/Teorema_della_scimmia_instancabile">teorema della scimmia instancabile</a> ci permette di affermare che <em>prima o poi</em> la stupid sort riuscirà ad ordinare qualsiasi array in input.<br />
Intuitivamente riusciamo a capire che non sia una buona soluzione ma come possiamo dimostrare questa supposizione? Ipotizziamo che l’array di Input abbia N elementi al suo interno e analizziamo in dettaglio il codice precedente:</p>

<ol>
  <li><code class="highlighter-rouge">is_sorted()</code>: questa funzione dato un array restituisce <code class="highlighter-rouge">true</code> se esso è ordinato, <code class="highlighter-rouge">false</code> altrimenti. Per poter sapere se un array è ordinato è sufficiente il seguente codice:
 <code class="highlighter-rouge">C++
 bool is_sorted(int array[N]){
     for(int i=0;i&lt;4;i++){           // Scorro l'array da 0 a N-1
         if(array[i] &gt; array[i+1])   // Se a[i] &gt; a[i+1]
             return false;           // Non è ordinato
     }
     return true;                    // Se ho passato tutto il for allora è ordinato
 }
</code>
 Quì si nasconde il primo ciclo che aumenta il tempo di esecuzione. Per quanto sia una funzione semplice un ciclo sulla dimensione dell’input è sempre da evitare. <code class="highlighter-rouge">is_sorted()</code> impiega <strong>N-1</strong> passi per completare la sua esecuzione.</li>
  <li><code class="highlighter-rouge">random_permutation()</code>:</li>
</ol>

<h3 id="tldr"><strong>TL;DR</strong></h3>

<p>Cicli sulla lunghezza dell’input = <strong>MALE</strong>.<br />
Dato un vettore in input di dimensione <strong>N</strong> cercate di evitare codici del tipo:</p>

<p><code class="highlighter-rouge">C++
    for(int i=0;i&lt;N; i++)                           // MALE
        for(int j=0;j&lt;N; j++)                       // MALISSIMO
            for(int k=0;k&lt;N; k++)                   // ¯\_(ツ)_/¯
                for(int devil=0; devil&lt;N; devil++)  // (╯°□°）╯︵ ┻━┻
</code></p>

</div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
